{"ast":null,"code":"// Copyright (C) 2011-2012 Software Languages Lab, Vrije Universiteit Brussel\n// This code is dual-licensed under both the Apache License and the MPL\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/* Version: MPL 1.1\n *\n * The contents of this file are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is a shim for the ES-Harmony reflection module\n *\n * The Initial Developer of the Original Code is\n * Tom Van Cutsem, Vrije Universiteit Brussel.\n * Portions created by the Initial Developer are Copyright (C) 2011-2012\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *\n */\n// ----------------------------------------------------------------------------\n// This file is a polyfill for the upcoming ECMAScript Reflect API,\n// including support for Proxies. See the draft specification at:\n// http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n// http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n// For an implementation of the Handler API, see handlers.js, which implements:\n// http://wiki.ecmascript.org/doku.php?id=harmony:virtual_object_api\n// This implementation supersedes the earlier polyfill at:\n// code.google.com/p/es-lab/source/browse/trunk/src/proxies/DirectProxies.js\n// This code was tested on tracemonkey / Firefox 12\n//  (and should run fine on older Firefox versions starting with FF4)\n// The code also works correctly on\n//   v8 --harmony_proxies --harmony_weakmaps (v3.6.5.1)\n// Language Dependencies:\n//  - ECMAScript 5/strict\n//  - \"old\" (i.e. non-direct) Harmony Proxies\n//  - Harmony WeakMaps\n// Patches:\n//  - Object.{freeze,seal,preventExtensions}\n//  - Object.{isFrozen,isSealed,isExtensible}\n//  - Object.getPrototypeOf\n//  - Object.keys\n//  - Object.prototype.valueOf\n//  - Object.prototype.isPrototypeOf\n//  - Object.prototype.toString\n//  - Object.prototype.hasOwnProperty\n//  - Object.getOwnPropertyDescriptor\n//  - Object.defineProperty\n//  - Object.defineProperties\n//  - Object.getOwnPropertyNames\n//  - Object.getOwnPropertySymbols\n//  - Object.getPrototypeOf\n//  - Object.setPrototypeOf\n//  - Object.assign\n//  - Function.prototype.toString\n//  - Date.prototype.toString\n//  - Array.isArray\n//  - Array.prototype.concat\n//  - Proxy\n// Adds new globals:\n//  - Reflect\n// Direct proxies can be created via Proxy(target, handler)\n// ----------------------------------------------------------------------------\n(function (global) {\n  // function-as-module pattern\n  \"use strict\"; // === Direct Proxies: Invariant Enforcement ===\n  // Direct proxies build on non-direct proxies by automatically wrapping\n  // all user-defined proxy handlers in a Validator handler that checks and\n  // enforces ES5 invariants.\n  // A direct proxy is a proxy for an existing object called the target object.\n  // A Validator handler is a wrapper for a target proxy handler H.\n  // The Validator forwards all operations to H, but additionally\n  // performs a number of integrity checks on the results of some traps,\n  // to make sure H does not violate the ES5 invariants w.r.t. non-configurable\n  // properties and non-extensible, sealed or frozen objects.\n  // For each property that H exposes as own, non-configurable\n  // (e.g. by returning a descriptor from a call to getOwnPropertyDescriptor)\n  // the Validator handler defines those properties on the target object.\n  // When the proxy becomes non-extensible, also configurable own properties\n  // are checked against the target.\n  // We will call properties that are defined on the target object\n  // \"fixed properties\".\n  // We will name fixed non-configurable properties \"sealed properties\".\n  // We will name fixed non-configurable non-writable properties \"frozen\n  // properties\".\n  // The Validator handler upholds the following invariants w.r.t. non-configurability:\n  // - getOwnPropertyDescriptor cannot report sealed properties as non-existent\n  // - getOwnPropertyDescriptor cannot report incompatible changes to the\n  //   attributes of a sealed property (e.g. reporting a non-configurable\n  //   property as configurable, or reporting a non-configurable, non-writable\n  //   property as writable)\n  // - getPropertyDescriptor cannot report sealed properties as non-existent\n  // - getPropertyDescriptor cannot report incompatible changes to the\n  //   attributes of a sealed property. It _can_ report incompatible changes\n  //   to the attributes of non-own, inherited properties.\n  // - defineProperty cannot make incompatible changes to the attributes of\n  //   sealed properties\n  // - deleteProperty cannot report a successful deletion of a sealed property\n  // - hasOwn cannot report a sealed property as non-existent\n  // - has cannot report a sealed property as non-existent\n  // - get cannot report inconsistent values for frozen data\n  //   properties, and must report undefined for sealed accessors with an\n  //   undefined getter\n  // - set cannot report a successful assignment for frozen data\n  //   properties or sealed accessors with an undefined setter.\n  // - get{Own}PropertyNames lists all sealed properties of the target.\n  // - keys lists all enumerable sealed properties of the target.\n  // - enumerate lists all enumerable sealed properties of the target.\n  // - if a property of a non-extensible proxy is reported as non-existent,\n  //   then it must forever be reported as non-existent. This applies to\n  //   own and inherited properties and is enforced in the\n  //   deleteProperty, get{Own}PropertyDescriptor, has{Own},\n  //   get{Own}PropertyNames, keys and enumerate traps\n  // Violation of any of these invariants by H will result in TypeError being\n  // thrown.\n  // Additionally, once Object.preventExtensions, Object.seal or Object.freeze\n  // is invoked on the proxy, the set of own property names for the proxy is\n  // fixed. Any property name that is not fixed is called a 'new' property.\n  // The Validator upholds the following invariants regarding extensibility:\n  // - getOwnPropertyDescriptor cannot report new properties as existent\n  //   (it must report them as non-existent by returning undefined)\n  // - defineProperty cannot successfully add a new property (it must reject)\n  // - getOwnPropertyNames cannot list new properties\n  // - hasOwn cannot report true for new properties (it must report false)\n  // - keys cannot list new properties\n  // Invariants currently not enforced:\n  // - getOwnPropertyNames lists only own property names\n  // - keys lists only enumerable own property names\n  // Both traps may list more property names than are actually defined on the\n  // target.\n  // Invariants with regard to inheritance are currently not enforced.\n  // - a non-configurable potentially inherited property on a proxy with\n  //   non-mutable ancestry cannot be reported as non-existent\n  // (An object with non-mutable ancestry is a non-extensible object whose\n  // [[Prototype]] is either null or an object with non-mutable ancestry.)\n  // Changes in Handler API compared to previous harmony:proxies, see:\n  // http://wiki.ecmascript.org/doku.php?id=strawman:direct_proxies\n  // http://wiki.ecmascript.org/doku.php?id=harmony:direct_proxies\n  // ----------------------------------------------------------------------------\n  // ---- WeakMap polyfill ----\n  // TODO: find a proper WeakMap polyfill\n  // define an empty WeakMap so that at least the Reflect module code\n  // will work in the absence of WeakMaps. Proxy emulation depends on\n  // actual WeakMaps, so will not work with this little shim.\n\n  if (typeof WeakMap === \"undefined\") {\n    global.WeakMap = function () {};\n\n    global.WeakMap.prototype = {\n      get: function get(k) {\n        return undefined;\n      },\n      set: function set(k, v) {\n        throw new Error(\"WeakMap not supported\");\n      }\n    };\n  } // ---- Normalization functions for property descriptors ----\n\n\n  function isStandardAttribute(name) {\n    return /^(get|set|value|writable|enumerable|configurable)$/.test(name);\n  } // Adapted from ES5 section 8.10.5\n\n\n  function toPropertyDescriptor(obj) {\n    if (Object(obj) !== obj) {\n      throw new TypeError(\"property descriptor should be an Object, given: \" + obj);\n    }\n\n    var desc = {};\n\n    if ('enumerable' in obj) {\n      desc.enumerable = !!obj.enumerable;\n    }\n\n    if ('configurable' in obj) {\n      desc.configurable = !!obj.configurable;\n    }\n\n    if ('value' in obj) {\n      desc.value = obj.value;\n    }\n\n    if ('writable' in obj) {\n      desc.writable = !!obj.writable;\n    }\n\n    if ('get' in obj) {\n      var getter = obj.get;\n\n      if (getter !== undefined && typeof getter !== \"function\") {\n        throw new TypeError(\"property descriptor 'get' attribute must be \" + \"callable or undefined, given: \" + getter);\n      }\n\n      desc.get = getter;\n    }\n\n    if ('set' in obj) {\n      var setter = obj.set;\n\n      if (setter !== undefined && typeof setter !== \"function\") {\n        throw new TypeError(\"property descriptor 'set' attribute must be \" + \"callable or undefined, given: \" + setter);\n      }\n\n      desc.set = setter;\n    }\n\n    if ('get' in desc || 'set' in desc) {\n      if ('value' in desc || 'writable' in desc) {\n        throw new TypeError(\"property descriptor cannot be both a data and an \" + \"accessor descriptor: \" + obj);\n      }\n    }\n\n    return desc;\n  }\n\n  function isAccessorDescriptor(desc) {\n    if (desc === undefined) return false;\n    return 'get' in desc || 'set' in desc;\n  }\n\n  function isDataDescriptor(desc) {\n    if (desc === undefined) return false;\n    return 'value' in desc || 'writable' in desc;\n  }\n\n  function isGenericDescriptor(desc) {\n    if (desc === undefined) return false;\n    return !isAccessorDescriptor(desc) && !isDataDescriptor(desc);\n  }\n\n  function toCompletePropertyDescriptor(desc) {\n    var internalDesc = toPropertyDescriptor(desc);\n\n    if (isGenericDescriptor(internalDesc) || isDataDescriptor(internalDesc)) {\n      if (!('value' in internalDesc)) {\n        internalDesc.value = undefined;\n      }\n\n      if (!('writable' in internalDesc)) {\n        internalDesc.writable = false;\n      }\n    } else {\n      if (!('get' in internalDesc)) {\n        internalDesc.get = undefined;\n      }\n\n      if (!('set' in internalDesc)) {\n        internalDesc.set = undefined;\n      }\n    }\n\n    if (!('enumerable' in internalDesc)) {\n      internalDesc.enumerable = false;\n    }\n\n    if (!('configurable' in internalDesc)) {\n      internalDesc.configurable = false;\n    }\n\n    return internalDesc;\n  }\n\n  function isEmptyDescriptor(desc) {\n    return !('get' in desc) && !('set' in desc) && !('value' in desc) && !('writable' in desc) && !('enumerable' in desc) && !('configurable' in desc);\n  }\n\n  function isEquivalentDescriptor(desc1, desc2) {\n    return sameValue(desc1.get, desc2.get) && sameValue(desc1.set, desc2.set) && sameValue(desc1.value, desc2.value) && sameValue(desc1.writable, desc2.writable) && sameValue(desc1.enumerable, desc2.enumerable) && sameValue(desc1.configurable, desc2.configurable);\n  } // copied from http://wiki.ecmascript.org/doku.php?id=harmony:egal\n\n\n  function sameValue(x, y) {\n    if (x === y) {\n      // 0 === -0, but they are not identical\n      return x !== 0 || 1 / x === 1 / y;\n    } // NaN !== NaN, but they are identical.\n    // NaNs are the only non-reflexive value, i.e., if x !== x,\n    // then x is a NaN.\n    // isNaN is broken: it converts its argument to number, so\n    // isNaN(\"foo\") => true\n\n\n    return x !== x && y !== y;\n  }\n  /**\n   * Returns a fresh property descriptor that is guaranteed\n   * to be complete (i.e. contain all the standard attributes).\n   * Additionally, any non-standard enumerable properties of\n   * attributes are copied over to the fresh descriptor.\n   *\n   * If attributes is undefined, returns undefined.\n   *\n   * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n   */\n\n\n  function normalizeAndCompletePropertyDescriptor(attributes) {\n    if (attributes === undefined) {\n      return undefined;\n    }\n\n    var desc = toCompletePropertyDescriptor(attributes); // Note: no need to call FromPropertyDescriptor(desc), as we represent\n    // \"internal\" property descriptors as proper Objects from the start\n\n    for (var name in attributes) {\n      if (!isStandardAttribute(name)) {\n        Object.defineProperty(desc, name, {\n          value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true\n        });\n      }\n    }\n\n    return desc;\n  }\n  /**\n   * Returns a fresh property descriptor whose standard\n   * attributes are guaranteed to be data properties of the right type.\n   * Additionally, any non-standard enumerable properties of\n   * attributes are copied over to the fresh descriptor.\n   *\n   * If attributes is undefined, will throw a TypeError.\n   *\n   * See also: http://wiki.ecmascript.org/doku.php?id=harmony:proxies_semantics\n   */\n\n\n  function normalizePropertyDescriptor(attributes) {\n    var desc = toPropertyDescriptor(attributes); // Note: no need to call FromGenericPropertyDescriptor(desc), as we represent\n    // \"internal\" property descriptors as proper Objects from the start\n\n    for (var name in attributes) {\n      if (!isStandardAttribute(name)) {\n        Object.defineProperty(desc, name, {\n          value: attributes[name],\n          writable: true,\n          enumerable: true,\n          configurable: true\n        });\n      }\n    }\n\n    return desc;\n  } // store a reference to the real ES5 primitives before patching them later\n\n\n  var prim_preventExtensions = Object.preventExtensions,\n      prim_seal = Object.seal,\n      prim_freeze = Object.freeze,\n      prim_isExtensible = Object.isExtensible,\n      prim_isSealed = Object.isSealed,\n      prim_isFrozen = Object.isFrozen,\n      prim_getPrototypeOf = Object.getPrototypeOf,\n      prim_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n      prim_defineProperty = Object.defineProperty,\n      prim_defineProperties = Object.defineProperties,\n      prim_keys = Object.keys,\n      prim_getOwnPropertyNames = Object.getOwnPropertyNames,\n      prim_getOwnPropertySymbols = Object.getOwnPropertySymbols,\n      prim_assign = Object.assign,\n      prim_isArray = Array.isArray,\n      prim_concat = Array.prototype.concat,\n      prim_isPrototypeOf = Object.prototype.isPrototypeOf,\n      prim_hasOwnProperty = Object.prototype.hasOwnProperty; // these will point to the patched versions of the respective methods on\n  // Object. They are used within this module as the \"intrinsic\" bindings\n  // of these methods (i.e. the \"original\" bindings as defined in the spec)\n\n  var Object_isFrozen, Object_isSealed, Object_isExtensible, Object_getPrototypeOf, Object_getOwnPropertyNames;\n  /**\n   * A property 'name' is fixed if it is an own property of the target.\n   */\n\n  function isFixed(name, target) {\n    return {}.hasOwnProperty.call(target, name);\n  }\n\n  function isSealed(name, target) {\n    var desc = Object.getOwnPropertyDescriptor(target, name);\n\n    if (desc === undefined) {\n      return false;\n    }\n\n    return desc.configurable === false;\n  }\n\n  function isSealedDesc(desc) {\n    return desc !== undefined && desc.configurable === false;\n  }\n  /**\n   * Performs all validation that Object.defineProperty performs,\n   * without actually defining the property. Returns a boolean\n   * indicating whether validation succeeded.\n   *\n   * Implementation transliterated from ES5.1 section 8.12.9\n   */\n\n\n  function isCompatibleDescriptor(extensible, current, desc) {\n    if (current === undefined && extensible === false) {\n      return false;\n    }\n\n    if (current === undefined && extensible === true) {\n      return true;\n    }\n\n    if (isEmptyDescriptor(desc)) {\n      return true;\n    }\n\n    if (isEquivalentDescriptor(current, desc)) {\n      return true;\n    }\n\n    if (current.configurable === false) {\n      if (desc.configurable === true) {\n        return false;\n      }\n\n      if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n        return false;\n      }\n    }\n\n    if (isGenericDescriptor(desc)) {\n      return true;\n    }\n\n    if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n      if (current.configurable === false) {\n        return false;\n      }\n\n      return true;\n    }\n\n    if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n      if (current.configurable === false) {\n        if (current.writable === false && desc.writable === true) {\n          return false;\n        }\n\n        if (current.writable === false) {\n          if ('value' in desc && !sameValue(desc.value, current.value)) {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n\n    if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n      if (current.configurable === false) {\n        if ('set' in desc && !sameValue(desc.set, current.set)) {\n          return false;\n        }\n\n        if ('get' in desc && !sameValue(desc.get, current.get)) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  } // ES6 7.3.11 SetIntegrityLevel\n  // level is one of \"sealed\" or \"frozen\"\n\n\n  function setIntegrityLevel(target, level) {\n    var ownProps = Object_getOwnPropertyNames(target);\n    var pendingException = undefined;\n\n    if (level === \"sealed\") {\n      var l = +ownProps.length;\n      var k;\n\n      for (var i = 0; i < l; i++) {\n        k = String(ownProps[i]);\n\n        try {\n          Object.defineProperty(target, k, {\n            configurable: false\n          });\n        } catch (e) {\n          if (pendingException === undefined) {\n            pendingException = e;\n          }\n        }\n      }\n    } else {\n      // level === \"frozen\"\n      var l = +ownProps.length;\n      var k;\n\n      for (var i = 0; i < l; i++) {\n        k = String(ownProps[i]);\n\n        try {\n          var currentDesc = Object.getOwnPropertyDescriptor(target, k);\n\n          if (currentDesc !== undefined) {\n            var desc;\n\n            if (isAccessorDescriptor(currentDesc)) {\n              desc = {\n                configurable: false\n              };\n            } else {\n              desc = {\n                configurable: false,\n                writable: false\n              };\n            }\n\n            Object.defineProperty(target, k, desc);\n          }\n        } catch (e) {\n          if (pendingException === undefined) {\n            pendingException = e;\n          }\n        }\n      }\n    }\n\n    if (pendingException !== undefined) {\n      throw pendingException;\n    }\n\n    return Reflect.preventExtensions(target);\n  } // ES6 7.3.12 TestIntegrityLevel\n  // level is one of \"sealed\" or \"frozen\"\n\n\n  function testIntegrityLevel(target, level) {\n    var isExtensible = Object_isExtensible(target);\n    if (isExtensible) return false;\n    var ownProps = Object_getOwnPropertyNames(target);\n    var pendingException = undefined;\n    var configurable = false;\n    var writable = false;\n    var l = +ownProps.length;\n    var k;\n    var currentDesc;\n\n    for (var i = 0; i < l; i++) {\n      k = String(ownProps[i]);\n\n      try {\n        currentDesc = Object.getOwnPropertyDescriptor(target, k);\n        configurable = configurable || currentDesc.configurable;\n\n        if (isDataDescriptor(currentDesc)) {\n          writable = writable || currentDesc.writable;\n        }\n      } catch (e) {\n        if (pendingException === undefined) {\n          pendingException = e;\n          configurable = true;\n        }\n      }\n    }\n\n    if (pendingException !== undefined) {\n      throw pendingException;\n    }\n\n    if (level === \"frozen\" && writable === true) {\n      return false;\n    }\n\n    if (configurable === true) {\n      return false;\n    }\n\n    return true;\n  } // ---- The Validator handler wrapper around user handlers ----\n\n  /**\n   * @param target the object wrapped by this proxy.\n   * As long as the proxy is extensible, only non-configurable properties\n   * are checked against the target. Once the proxy becomes non-extensible,\n   * invariants w.r.t. non-extensibility are also enforced.\n   *\n   * @param handler the handler of the direct proxy. The object emulated by\n   * this handler is validated against the target object of the direct proxy.\n   * Any violations that the handler makes against the invariants\n   * of the target will cause a TypeError to be thrown.\n   *\n   * Both target and handler must be proper Objects at initialization time.\n   */\n\n\n  function Validator(target, handler) {\n    // for non-revokable proxies, these are const references\n    // for revokable proxies, on revocation:\n    // - this.target is set to null\n    // - this.handler is set to a handler that throws on all traps\n    this.target = target;\n    this.handler = handler;\n  }\n\n  Validator.prototype = {\n    /**\n     * If getTrap returns undefined, the caller should perform the\n     * default forwarding behavior.\n     * If getTrap returns normally otherwise, the return value\n     * will be a callable trap function. When calling the trap function,\n     * the caller is responsible for binding its |this| to |this.handler|.\n     */\n    getTrap: function getTrap(trapName) {\n      var trap = this.handler[trapName];\n\n      if (trap === undefined) {\n        // the trap was not defined,\n        // perform the default forwarding behavior\n        return undefined;\n      }\n\n      if (typeof trap !== \"function\") {\n        throw new TypeError(trapName + \" trap is not callable: \" + trap);\n      }\n\n      return trap;\n    },\n    // === fundamental traps ===\n\n    /**\n     * If name denotes a fixed property, check:\n     *   - whether targetHandler reports it as existent\n     *   - whether the returned descriptor is compatible with the fixed property\n     * If the proxy is non-extensible, check:\n     *   - whether name is not a new property\n     * Additionally, the returned descriptor is normalized and completed.\n     */\n    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(name) {\n      \"use strict\";\n\n      var trap = this.getTrap(\"getOwnPropertyDescriptor\");\n\n      if (trap === undefined) {\n        return Reflect.getOwnPropertyDescriptor(this.target, name);\n      }\n\n      name = String(name);\n      var desc = trap.call(this.handler, this.target, name);\n      desc = normalizeAndCompletePropertyDescriptor(desc);\n      var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n      var extensible = Object.isExtensible(this.target);\n\n      if (desc === undefined) {\n        if (isSealedDesc(targetDesc)) {\n          throw new TypeError(\"cannot report non-configurable property '\" + name + \"' as non-existent\");\n        }\n\n        if (!extensible && targetDesc !== undefined) {\n          // if handler is allowed to return undefined, we cannot guarantee\n          // that it will not return a descriptor for this property later.\n          // Once a property has been reported as non-existent on a non-extensible\n          // object, it should forever be reported as non-existent\n          throw new TypeError(\"cannot report existing own property '\" + name + \"' as non-existent on a non-extensible object\");\n        }\n\n        return undefined;\n      } // at this point, we know (desc !== undefined), i.e.\n      // targetHandler reports 'name' as an existing property\n      // Note: we could collapse the following two if-tests into a single\n      // test. Separating out the cases to improve error reporting.\n\n\n      if (!extensible) {\n        if (targetDesc === undefined) {\n          throw new TypeError(\"cannot report a new own property '\" + name + \"' on a non-extensible object\");\n        }\n      }\n\n      if (name !== undefined) {\n        if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n          throw new TypeError(\"cannot report incompatible property descriptor \" + \"for property '\" + name + \"'\");\n        }\n      }\n\n      if (desc.configurable === false) {\n        if (targetDesc === undefined || targetDesc.configurable === true) {\n          // if the property is configurable or non-existent on the target,\n          // but is reported as a non-configurable property, it may later be\n          // reported as configurable or non-existent, which violates the\n          // invariant that if the property might change or disappear, the\n          // configurable attribute must be true.\n          throw new TypeError(\"cannot report a non-configurable descriptor \" + \"for configurable or non-existent property '\" + name + \"'\");\n        }\n\n        if ('writable' in desc && desc.writable === false) {\n          if (targetDesc.writable === true) {\n            // if the property is non-configurable, writable on the target,\n            // but is reported as non-configurable, non-writable, it may later\n            // be reported as non-configurable, writable again, which violates\n            // the invariant that a non-configurable, non-writable property\n            // may not change state.\n            throw new TypeError(\"cannot report non-configurable, writable property '\" + name + \"' as non-configurable, non-writable\");\n          }\n        }\n      }\n\n      return desc;\n    },\n\n    /**\n     * In the direct proxies design with refactored prototype climbing,\n     * this trap is deprecated. For proxies-as-prototypes, instead\n     * of calling this trap, the get, set, has or enumerate traps are\n     * called instead.\n     *\n     * In this implementation, we \"abuse\" getPropertyDescriptor to\n     * support trapping the get or set traps for proxies-as-prototypes.\n     * We do this by returning a getter/setter pair that invokes\n     * the corresponding traps.\n     *\n     * While this hack works for inherited property access, it has some\n     * quirks:\n     *\n     * In Firefox, this trap is only called after a prior invocation\n     * of the 'has' trap has returned true. Hence, expect the following\n     * behavior:\n     * <code>\n     * var child = Object.create(Proxy(target, handler));\n     * child[name] // triggers handler.has(target, name)\n     * // if that returns true, triggers handler.get(target, name, child)\n     * </code>\n     *\n     * On v8, the 'in' operator, when applied to an object that inherits\n     * from a proxy, will call getPropertyDescriptor and walk the proto-chain.\n     * That calls the below getPropertyDescriptor trap on the proxy. The\n     * result of the 'in'-operator is then determined by whether this trap\n     * returns undefined or a property descriptor object. That is why\n     * we first explicitly trigger the 'has' trap to determine whether\n     * the property exists.\n     *\n     * This has the side-effect that when enumerating properties on\n     * an object that inherits from a proxy in v8, only properties\n     * for which 'has' returns true are returned:\n     *\n     * <code>\n     * var child = Object.create(Proxy(target, handler));\n     * for (var prop in child) {\n     *   // only enumerates prop if (prop in child) returns true\n     * }\n     * </code>\n     */\n    getPropertyDescriptor: function getPropertyDescriptor(name) {\n      var handler = this;\n      if (!handler.has(name)) return undefined;\n      return {\n        get: function get() {\n          return handler.get(this, name);\n        },\n        set: function set(val) {\n          if (handler.set(this, name, val)) {\n            return val;\n          } else {\n            throw new TypeError(\"failed assignment to \" + name);\n          }\n        },\n        enumerable: true,\n        configurable: true\n      };\n    },\n\n    /**\n     * If name denotes a fixed property, check for incompatible changes.\n     * If the proxy is non-extensible, check that new properties are rejected.\n     */\n    defineProperty: function defineProperty(name, desc) {\n      // TODO(tvcutsem): the current tracemonkey implementation of proxies\n      // auto-completes 'desc', which is not correct. 'desc' should be\n      // normalized, but not completed. Consider:\n      // Object.defineProperty(proxy, 'foo', {enumerable:false})\n      // This trap will receive desc =\n      //  {value:undefined,writable:false,enumerable:false,configurable:false}\n      // This will also set all other attributes to their default value,\n      // which is unexpected and different from [[DefineOwnProperty]].\n      // Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n      var trap = this.getTrap(\"defineProperty\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.defineProperty(this.target, name, desc);\n      }\n\n      name = String(name);\n      var descObj = normalizePropertyDescriptor(desc);\n      var success = trap.call(this.handler, this.target, name, descObj);\n      success = !!success; // coerce to Boolean\n\n      if (success === true) {\n        var targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n        var extensible = Object.isExtensible(this.target); // Note: we could collapse the following two if-tests into a single\n        // test. Separating out the cases to improve error reporting.\n\n        if (!extensible) {\n          if (targetDesc === undefined) {\n            throw new TypeError(\"cannot successfully add a new property '\" + name + \"' to a non-extensible object\");\n          }\n        }\n\n        if (targetDesc !== undefined) {\n          if (!isCompatibleDescriptor(extensible, targetDesc, desc)) {\n            throw new TypeError(\"cannot define incompatible property \" + \"descriptor for property '\" + name + \"'\");\n          }\n\n          if (isDataDescriptor(targetDesc) && targetDesc.configurable === false && targetDesc.writable === true) {\n            if (desc.configurable === false && desc.writable === false) {\n              // if the property is non-configurable, writable on the target\n              // but was successfully reported to be updated to\n              // non-configurable, non-writable, it can later be reported\n              // again as non-configurable, writable, which violates\n              // the invariant that non-configurable, non-writable properties\n              // cannot change state\n              throw new TypeError(\"cannot successfully define non-configurable, writable \" + \" property '\" + name + \"' as non-configurable, non-writable\");\n            }\n          }\n        }\n\n        if (desc.configurable === false && !isSealedDesc(targetDesc)) {\n          // if the property is configurable or non-existent on the target,\n          // but is successfully being redefined as a non-configurable property,\n          // it may later be reported as configurable or non-existent, which violates\n          // the invariant that if the property might change or disappear, the\n          // configurable attribute must be true.\n          throw new TypeError(\"cannot successfully define a non-configurable \" + \"descriptor for configurable or non-existent property '\" + name + \"'\");\n        }\n      }\n\n      return success;\n    },\n\n    /**\n     * On success, check whether the target object is indeed non-extensible.\n     */\n    preventExtensions: function preventExtensions() {\n      var trap = this.getTrap(\"preventExtensions\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.preventExtensions(this.target);\n      }\n\n      var success = trap.call(this.handler, this.target);\n      success = !!success; // coerce to Boolean\n\n      if (success) {\n        if (Object_isExtensible(this.target)) {\n          throw new TypeError(\"can't report extensible object as non-extensible: \" + this.target);\n        }\n      }\n\n      return success;\n    },\n\n    /**\n     * If name denotes a sealed property, check whether handler rejects.\n     */\n    delete: function _delete(name) {\n      \"use strict\";\n\n      var trap = this.getTrap(\"deleteProperty\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.deleteProperty(this.target, name);\n      }\n\n      name = String(name);\n      var res = trap.call(this.handler, this.target, name);\n      res = !!res; // coerce to Boolean\n\n      var targetDesc;\n\n      if (res === true) {\n        targetDesc = Object.getOwnPropertyDescriptor(this.target, name);\n\n        if (targetDesc !== undefined && targetDesc.configurable === false) {\n          throw new TypeError(\"property '\" + name + \"' is non-configurable \" + \"and can't be deleted\");\n        }\n\n        if (targetDesc !== undefined && !Object_isExtensible(this.target)) {\n          // if the property still exists on a non-extensible target but\n          // is reported as successfully deleted, it may later be reported\n          // as present, which violates the invariant that an own property,\n          // deleted from a non-extensible object cannot reappear.\n          throw new TypeError(\"cannot successfully delete existing property '\" + name + \"' on a non-extensible object\");\n        }\n      }\n\n      return res;\n    },\n\n    /**\n     * The getOwnPropertyNames trap was replaced by the ownKeys trap,\n     * which now also returns an array (of strings or symbols) and\n     * which performs the same rigorous invariant checks as getOwnPropertyNames\n     *\n     * See issue #48 on how this trap can still get invoked by external libs\n     * that don't use the patched Object.getOwnPropertyNames function.\n     */\n    getOwnPropertyNames: function getOwnPropertyNames() {\n      // Note: removed deprecation warning to avoid dependency on 'console'\n      // (and on node, should anyway use util.deprecate). Deprecation warnings\n      // can also be annoying when they are outside of the user's control, e.g.\n      // when an external library calls unpatched Object.getOwnPropertyNames.\n      // Since there is a clean fallback to `ownKeys`, the fact that the\n      // deprecated method is still called is mostly harmless anyway.\n      // See also issues #65 and #66.\n      // console.warn(\"getOwnPropertyNames trap is deprecated. Use ownKeys instead\");\n      return this.ownKeys();\n    },\n\n    /**\n     * Checks whether the trap result does not contain any new properties\n     * if the proxy is non-extensible.\n     *\n     * Any own non-configurable properties of the target that are not included\n     * in the trap result give rise to a TypeError. As such, we check whether the\n     * returned result contains at least all sealed properties of the target\n     * object.\n     *\n     * Additionally, the trap result is normalized.\n     * Instead of returning the trap result directly:\n     *  - create and return a fresh Array,\n     *  - of which each element is coerced to a String\n     *\n     * This trap is called a.o. by Reflect.ownKeys, Object.getOwnPropertyNames\n     * and Object.keys (the latter filters out only the enumerable own properties).\n     */\n    ownKeys: function ownKeys() {\n      var trap = this.getTrap(\"ownKeys\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.ownKeys(this.target);\n      }\n\n      var trapResult = trap.call(this.handler, this.target); // propNames is used as a set of strings\n\n      var propNames = Object.create(null);\n      var numProps = +trapResult.length;\n      var result = new Array(numProps);\n\n      for (var i = 0; i < numProps; i++) {\n        var s = String(trapResult[i]);\n\n        if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n          // non-extensible proxies don't tolerate new own property names\n          throw new TypeError(\"ownKeys trap cannot list a new \" + \"property '\" + s + \"' on a non-extensible object\");\n        }\n\n        propNames[s] = true;\n        result[i] = s;\n      }\n\n      var ownProps = Object_getOwnPropertyNames(this.target);\n      var target = this.target;\n      ownProps.forEach(function (ownProp) {\n        if (!propNames[ownProp]) {\n          if (isSealed(ownProp, target)) {\n            throw new TypeError(\"ownKeys trap failed to include \" + \"non-configurable property '\" + ownProp + \"'\");\n          }\n\n          if (!Object.isExtensible(target) && isFixed(ownProp, target)) {\n            // if handler is allowed to report ownProp as non-existent,\n            // we cannot guarantee that it will never later report it as\n            // existent. Once a property has been reported as non-existent\n            // on a non-extensible object, it should forever be reported as\n            // non-existent\n            throw new TypeError(\"ownKeys trap cannot report existing own property '\" + ownProp + \"' as non-existent on a non-extensible object\");\n          }\n        }\n      });\n      return result;\n    },\n\n    /**\n     * Checks whether the trap result is consistent with the state of the\n     * wrapped target.\n     */\n    isExtensible: function isExtensible() {\n      var trap = this.getTrap(\"isExtensible\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.isExtensible(this.target);\n      }\n\n      var result = trap.call(this.handler, this.target);\n      result = !!result; // coerce to Boolean\n\n      var state = Object_isExtensible(this.target);\n\n      if (result !== state) {\n        if (result) {\n          throw new TypeError(\"cannot report non-extensible object as extensible: \" + this.target);\n        } else {\n          throw new TypeError(\"cannot report extensible object as non-extensible: \" + this.target);\n        }\n      }\n\n      return state;\n    },\n\n    /**\n     * Check whether the trap result corresponds to the target's [[Prototype]]\n     */\n    getPrototypeOf: function getPrototypeOf() {\n      var trap = this.getTrap(\"getPrototypeOf\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.getPrototypeOf(this.target);\n      }\n\n      var allegedProto = trap.call(this.handler, this.target);\n\n      if (!Object_isExtensible(this.target)) {\n        var actualProto = Object_getPrototypeOf(this.target);\n\n        if (!sameValue(allegedProto, actualProto)) {\n          throw new TypeError(\"prototype value does not match: \" + this.target);\n        }\n      }\n\n      return allegedProto;\n    },\n\n    /**\n     * If target is non-extensible and setPrototypeOf trap returns true,\n     * check whether the trap result corresponds to the target's [[Prototype]]\n     */\n    setPrototypeOf: function setPrototypeOf(newProto) {\n      var trap = this.getTrap(\"setPrototypeOf\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.setPrototypeOf(this.target, newProto);\n      }\n\n      var success = trap.call(this.handler, this.target, newProto);\n      success = !!success;\n\n      if (success && !Object_isExtensible(this.target)) {\n        var actualProto = Object_getPrototypeOf(this.target);\n\n        if (!sameValue(newProto, actualProto)) {\n          throw new TypeError(\"prototype value does not match: \" + this.target);\n        }\n      }\n\n      return success;\n    },\n\n    /**\n     * In the direct proxies design with refactored prototype climbing,\n     * this trap is deprecated. For proxies-as-prototypes, for-in will\n     * call the enumerate() trap. If that trap is not defined, the\n     * operation is forwarded to the target, no more fallback on this\n     * fundamental trap.\n     */\n    getPropertyNames: function getPropertyNames() {\n      throw new TypeError(\"getPropertyNames trap is deprecated\");\n    },\n    // === derived traps ===\n\n    /**\n     * If name denotes a fixed property, check whether the trap returns true.\n     */\n    has: function has(name) {\n      var trap = this.getTrap(\"has\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.has(this.target, name);\n      }\n\n      name = String(name);\n      var res = trap.call(this.handler, this.target, name);\n      res = !!res; // coerce to Boolean\n\n      if (res === false) {\n        if (isSealed(name, this.target)) {\n          throw new TypeError(\"cannot report existing non-configurable own \" + \"property '\" + name + \"' as a non-existent \" + \"property\");\n        }\n\n        if (!Object.isExtensible(this.target) && isFixed(name, this.target)) {\n          // if handler is allowed to return false, we cannot guarantee\n          // that it will not return true for this property later.\n          // Once a property has been reported as non-existent on a non-extensible\n          // object, it should forever be reported as non-existent\n          throw new TypeError(\"cannot report existing own property '\" + name + \"' as non-existent on a non-extensible object\");\n        }\n      } // if res === true, we don't need to check for extensibility\n      // even for a non-extensible proxy that has no own name property,\n      // the property may have been inherited\n\n\n      return res;\n    },\n\n    /**\n     * If name denotes a fixed non-configurable, non-writable data property,\n     * check its return value against the previously asserted value of the\n     * fixed property.\n     */\n    get: function get(receiver, name) {\n      // experimental support for invoke() trap on platforms that\n      // support __noSuchMethod__\n\n      /*\n      if (name === '__noSuchMethod__') {\n        var handler = this;\n        return function(name, args) {\n          return handler.invoke(receiver, name, args);\n        }\n      }\n      */\n      var trap = this.getTrap(\"get\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.get(this.target, name, receiver);\n      }\n\n      name = String(name);\n      var res = trap.call(this.handler, this.target, name, receiver);\n      var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name); // check consistency of the returned value\n\n      if (fixedDesc !== undefined) {\n        // getting an existing property\n        if (isDataDescriptor(fixedDesc) && fixedDesc.configurable === false && fixedDesc.writable === false) {\n          // own frozen data property\n          if (!sameValue(res, fixedDesc.value)) {\n            throw new TypeError(\"cannot report inconsistent value for \" + \"non-writable, non-configurable property '\" + name + \"'\");\n          }\n        } else {\n          // it's an accessor property\n          if (isAccessorDescriptor(fixedDesc) && fixedDesc.configurable === false && fixedDesc.get === undefined) {\n            if (res !== undefined) {\n              throw new TypeError(\"must report undefined for non-configurable \" + \"accessor property '\" + name + \"' without getter\");\n            }\n          }\n        }\n      }\n\n      return res;\n    },\n\n    /**\n     * If name denotes a fixed non-configurable, non-writable data property,\n     * check that the trap rejects the assignment.\n     */\n    set: function set(receiver, name, val) {\n      var trap = this.getTrap(\"set\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.set(this.target, name, val, receiver);\n      }\n\n      name = String(name);\n      var res = trap.call(this.handler, this.target, name, val, receiver);\n      res = !!res; // coerce to Boolean\n      // if success is reported, check whether property is truly assignable\n\n      if (res === true) {\n        var fixedDesc = Object.getOwnPropertyDescriptor(this.target, name);\n\n        if (fixedDesc !== undefined) {\n          // setting an existing property\n          if (isDataDescriptor(fixedDesc) && fixedDesc.configurable === false && fixedDesc.writable === false) {\n            if (!sameValue(val, fixedDesc.value)) {\n              throw new TypeError(\"cannot successfully assign to a \" + \"non-writable, non-configurable property '\" + name + \"'\");\n            }\n          } else {\n            if (isAccessorDescriptor(fixedDesc) && fixedDesc.configurable === false && // non-configurable\n            fixedDesc.set === undefined) {\n              // accessor with undefined setter\n              throw new TypeError(\"setting a property '\" + name + \"' that has \" + \" only a getter\");\n            }\n          }\n        }\n      }\n\n      return res;\n    },\n\n    /**\n     * Any own enumerable non-configurable properties of the target that are not\n     * included in the trap result give rise to a TypeError. As such, we check\n     * whether the returned result contains at least all sealed enumerable properties\n     * of the target object.\n     *\n     * The trap should return an iterator.\n     *\n     * However, as implementations of pre-direct proxies still expect enumerate\n     * to return an array of strings, we convert the iterator into an array.\n     */\n    enumerate: function enumerate() {\n      var trap = this.getTrap(\"enumerate\");\n\n      if (trap === undefined) {\n        // default forwarding behavior\n        var trapResult = Reflect.enumerate(this.target);\n        var result = [];\n        var nxt = trapResult.next();\n\n        while (!nxt.done) {\n          result.push(String(nxt.value));\n          nxt = trapResult.next();\n        }\n\n        return result;\n      }\n\n      var trapResult = trap.call(this.handler, this.target);\n\n      if (trapResult === null || trapResult === undefined || trapResult.next === undefined) {\n        throw new TypeError(\"enumerate trap should return an iterator, got: \" + trapResult);\n      } // propNames is used as a set of strings\n\n\n      var propNames = Object.create(null); // var numProps = +trapResult.length;\n\n      var result = []; // new Array(numProps);\n      // trapResult is supposed to be an iterator\n      // drain iterator to array as current implementations still expect\n      // enumerate to return an array of strings\n\n      var nxt = trapResult.next();\n\n      while (!nxt.done) {\n        var s = String(nxt.value);\n\n        if (propNames[s]) {\n          throw new TypeError(\"enumerate trap cannot list a \" + \"duplicate property '\" + s + \"'\");\n        }\n\n        propNames[s] = true;\n        result.push(s);\n        nxt = trapResult.next();\n      }\n      /*for (var i = 0; i < numProps; i++) {\n        var s = String(trapResult[i]);\n        if (propNames[s]) {\n          throw new TypeError(\"enumerate trap cannot list a \"+\n                              \"duplicate property '\"+s+\"'\");\n        }\n         propNames[s] = true;\n        result[i] = s;\n      } */\n\n\n      var ownEnumerableProps = Object.keys(this.target);\n      var target = this.target;\n      ownEnumerableProps.forEach(function (ownEnumerableProp) {\n        if (!propNames[ownEnumerableProp]) {\n          if (isSealed(ownEnumerableProp, target)) {\n            throw new TypeError(\"enumerate trap failed to include \" + \"non-configurable enumerable property '\" + ownEnumerableProp + \"'\");\n          }\n\n          if (!Object.isExtensible(target) && isFixed(ownEnumerableProp, target)) {\n            // if handler is allowed not to report ownEnumerableProp as an own\n            // property, we cannot guarantee that it will never report it as\n            // an own property later. Once a property has been reported as\n            // non-existent on a non-extensible object, it should forever be\n            // reported as non-existent\n            throw new TypeError(\"cannot report existing own property '\" + ownEnumerableProp + \"' as non-existent on a \" + \"non-extensible object\");\n          }\n        }\n      });\n      return result;\n    },\n\n    /**\n     * The iterate trap is deprecated by the enumerate trap.\n     */\n    iterate: Validator.prototype.enumerate,\n\n    /**\n     * Any own non-configurable properties of the target that are not included\n     * in the trap result give rise to a TypeError. As such, we check whether the\n     * returned result contains at least all sealed properties of the target\n     * object.\n     *\n     * The trap result is normalized.\n     * The trap result is not returned directly. Instead:\n     *  - create and return a fresh Array,\n     *  - of which each element is coerced to String,\n     *  - which does not contain duplicates\n     *\n     * FIXME: keys trap is deprecated\n     */\n\n    /*\n    keys: function() {\n      var trap = this.getTrap(\"keys\");\n      if (trap === undefined) {\n        // default forwarding behavior\n        return Reflect.keys(this.target);\n      }\n       var trapResult = trap.call(this.handler, this.target);\n       // propNames is used as a set of strings\n      var propNames = Object.create(null);\n      var numProps = +trapResult.length;\n      var result = new Array(numProps);\n       for (var i = 0; i < numProps; i++) {\n       var s = String(trapResult[i]);\n       if (propNames[s]) {\n         throw new TypeError(\"keys trap cannot list a \"+\n                             \"duplicate property '\"+s+\"'\");\n       }\n       if (!Object.isExtensible(this.target) && !isFixed(s, this.target)) {\n         // non-extensible proxies don't tolerate new own property names\n         throw new TypeError(\"keys trap cannot list a new \"+\n                             \"property '\"+s+\"' on a non-extensible object\");\n       }\n        propNames[s] = true;\n       result[i] = s;\n      }\n       var ownEnumerableProps = Object.keys(this.target);\n      var target = this.target;\n      ownEnumerableProps.forEach(function (ownEnumerableProp) {\n        if (!propNames[ownEnumerableProp]) {\n          if (isSealed(ownEnumerableProp, target)) {\n            throw new TypeError(\"keys trap failed to include \"+\n                                \"non-configurable enumerable property '\"+\n                                ownEnumerableProp+\"'\");\n          }\n          if (!Object.isExtensible(target) &&\n              isFixed(ownEnumerableProp, target)) {\n              // if handler is allowed not to report ownEnumerableProp as an own\n              // property, we cannot guarantee that it will never report it as\n              // an own property later. Once a property has been reported as\n              // non-existent on a non-extensible object, it should forever be\n              // reported as non-existent\n              throw new TypeError(\"cannot report existing own property '\"+\n                                  ownEnumerableProp+\"' as non-existent on a \"+\n                                  \"non-extensible object\");\n          }\n        }\n      });\n       return result;\n    },\n    */\n\n    /**\n     * New trap that reifies [[Call]].\n     * If the target is a function, then a call to\n     *   proxy(...args)\n     * Triggers this trap\n     */\n    apply: function apply(target, thisBinding, args) {\n      var trap = this.getTrap(\"apply\");\n\n      if (trap === undefined) {\n        return Reflect.apply(target, thisBinding, args);\n      }\n\n      if (typeof this.target === \"function\") {\n        return trap.call(this.handler, target, thisBinding, args);\n      } else {\n        throw new TypeError(\"apply: \" + target + \" is not a function\");\n      }\n    },\n\n    /**\n     * New trap that reifies [[Construct]].\n     * If the target is a function, then a call to\n     *   new proxy(...args)\n     * Triggers this trap\n     */\n    construct: function construct(target, args, newTarget) {\n      var trap = this.getTrap(\"construct\");\n\n      if (trap === undefined) {\n        return Reflect.construct(target, args, newTarget);\n      }\n\n      if (typeof target !== \"function\") {\n        throw new TypeError(\"new: \" + target + \" is not a function\");\n      }\n\n      if (newTarget === undefined) {\n        newTarget = target;\n      } else {\n        if (typeof newTarget !== \"function\") {\n          throw new TypeError(\"new: \" + newTarget + \" is not a function\");\n        }\n      }\n\n      return trap.call(this.handler, target, args, newTarget);\n    }\n  }; // ---- end of the Validator handler wrapper handler ----\n  // In what follows, a 'direct proxy' is a proxy\n  // whose handler is a Validator. Such proxies can be made non-extensible,\n  // sealed or frozen without losing the ability to trap.\n  // maps direct proxies to their Validator handlers\n\n  var directProxies = new WeakMap(); // patch Object.{preventExtensions,seal,freeze} so that\n  // they recognize fixable proxies and act accordingly\n\n  Object.preventExtensions = function (subject) {\n    var vhandler = directProxies.get(subject);\n\n    if (vhandler !== undefined) {\n      if (vhandler.preventExtensions()) {\n        return subject;\n      } else {\n        throw new TypeError(\"preventExtensions on \" + subject + \" rejected\");\n      }\n    } else {\n      return prim_preventExtensions(subject);\n    }\n  };\n\n  Object.seal = function (subject) {\n    setIntegrityLevel(subject, \"sealed\");\n    return subject;\n  };\n\n  Object.freeze = function (subject) {\n    setIntegrityLevel(subject, \"frozen\");\n    return subject;\n  };\n\n  Object.isExtensible = Object_isExtensible = function Object_isExtensible(subject) {\n    var vHandler = directProxies.get(subject);\n\n    if (vHandler !== undefined) {\n      return vHandler.isExtensible();\n    } else {\n      return prim_isExtensible(subject);\n    }\n  };\n\n  Object.isSealed = Object_isSealed = function Object_isSealed(subject) {\n    return testIntegrityLevel(subject, \"sealed\");\n  };\n\n  Object.isFrozen = Object_isFrozen = function Object_isFrozen(subject) {\n    return testIntegrityLevel(subject, \"frozen\");\n  };\n\n  Object.getPrototypeOf = Object_getPrototypeOf = function Object_getPrototypeOf(subject) {\n    var vHandler = directProxies.get(subject);\n\n    if (vHandler !== undefined) {\n      return vHandler.getPrototypeOf();\n    } else {\n      return prim_getPrototypeOf(subject);\n    }\n  }; // patch Object.getOwnPropertyDescriptor to directly call\n  // the Validator.prototype.getOwnPropertyDescriptor trap\n  // This is to circumvent an assertion in the built-in Proxy\n  // trapping mechanism of v8, which disallows that trap to\n  // return non-configurable property descriptors (as per the\n  // old Proxy design)\n\n\n  Object.getOwnPropertyDescriptor = function (subject, name) {\n    var vhandler = directProxies.get(subject);\n\n    if (vhandler !== undefined) {\n      return vhandler.getOwnPropertyDescriptor(name);\n    } else {\n      return prim_getOwnPropertyDescriptor(subject, name);\n    }\n  }; // patch Object.defineProperty to directly call\n  // the Validator.prototype.defineProperty trap\n  // This is to circumvent two issues with the built-in\n  // trap mechanism:\n  // 1) the current tracemonkey implementation of proxies\n  // auto-completes 'desc', which is not correct. 'desc' should be\n  // normalized, but not completed. Consider:\n  // Object.defineProperty(proxy, 'foo', {enumerable:false})\n  // This trap will receive desc =\n  //  {value:undefined,writable:false,enumerable:false,configurable:false}\n  // This will also set all other attributes to their default value,\n  // which is unexpected and different from [[DefineOwnProperty]].\n  // Bug filed: https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n  // 2) the current spidermonkey implementation does not\n  // throw an exception when this trap returns 'false', but instead silently\n  // ignores the operation (this is regardless of strict-mode)\n  // 2a) v8 does throw an exception for this case, but includes the rather\n  //     unhelpful error message:\n  // 'Proxy handler #<Object> returned false from 'defineProperty' trap'\n\n\n  Object.defineProperty = function (subject, name, desc) {\n    var vhandler = directProxies.get(subject);\n\n    if (vhandler !== undefined) {\n      var normalizedDesc = normalizePropertyDescriptor(desc);\n      var success = vhandler.defineProperty(name, normalizedDesc);\n\n      if (success === false) {\n        throw new TypeError(\"can't redefine property '\" + name + \"'\");\n      }\n\n      return subject;\n    } else {\n      return prim_defineProperty(subject, name, desc);\n    }\n  };\n\n  Object.defineProperties = function (subject, descs) {\n    var vhandler = directProxies.get(subject);\n\n    if (vhandler !== undefined) {\n      var names = Object.keys(descs);\n\n      for (var i = 0; i < names.length; i++) {\n        var name = names[i];\n        var normalizedDesc = normalizePropertyDescriptor(descs[name]);\n        var success = vhandler.defineProperty(name, normalizedDesc);\n\n        if (success === false) {\n          throw new TypeError(\"can't redefine property '\" + name + \"'\");\n        }\n      }\n\n      return subject;\n    } else {\n      return prim_defineProperties(subject, descs);\n    }\n  };\n\n  Object.keys = function (subject) {\n    var vHandler = directProxies.get(subject);\n\n    if (vHandler !== undefined) {\n      var ownKeys = vHandler.ownKeys();\n      var result = [];\n\n      for (var i = 0; i < ownKeys.length; i++) {\n        var k = String(ownKeys[i]);\n        var desc = Object.getOwnPropertyDescriptor(subject, k);\n\n        if (desc !== undefined && desc.enumerable === true) {\n          result.push(k);\n        }\n      }\n\n      return result;\n    } else {\n      return prim_keys(subject);\n    }\n  };\n\n  Object.getOwnPropertyNames = Object_getOwnPropertyNames = function Object_getOwnPropertyNames(subject) {\n    var vHandler = directProxies.get(subject);\n\n    if (vHandler !== undefined) {\n      return vHandler.ownKeys();\n    } else {\n      return prim_getOwnPropertyNames(subject);\n    }\n  }; // fixes issue #71 (Calling Object.getOwnPropertySymbols() on a Proxy\n  // throws an error)\n\n\n  if (prim_getOwnPropertySymbols !== undefined) {\n    Object.getOwnPropertySymbols = function (subject) {\n      var vHandler = directProxies.get(subject);\n\n      if (vHandler !== undefined) {\n        // as this shim does not support symbols, a Proxy never advertises\n        // any symbol-valued own properties\n        return [];\n      } else {\n        return prim_getOwnPropertySymbols(subject);\n      }\n    };\n  } // fixes issue #72 ('Illegal access' error when using Object.assign)\n  // Object.assign polyfill based on a polyfill posted on MDN: \n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/\\\n  //  Global_Objects/Object/assign\n  // Note that this polyfill does not support Symbols, but this Proxy Shim\n  // does not support Symbols anyway.\n\n\n  if (prim_assign !== undefined) {\n    Object.assign = function (target) {\n      // check if any argument is a proxy object\n      var noProxies = true;\n\n      for (var i = 0; i < arguments.length; i++) {\n        var vHandler = directProxies.get(arguments[i]);\n\n        if (vHandler !== undefined) {\n          noProxies = false;\n          break;\n        }\n      }\n\n      if (noProxies) {\n        // not a single argument is a proxy, perform built-in algorithm\n        return prim_assign.apply(Object, arguments);\n      } // there is at least one proxy argument, use the polyfill\n\n\n      if (target === undefined || target === null) {\n        throw new TypeError('Cannot convert undefined or null to object');\n      }\n\n      var output = Object(target);\n\n      for (var index = 1; index < arguments.length; index++) {\n        var source = arguments[index];\n\n        if (source !== undefined && source !== null) {\n          for (var nextKey in source) {\n            if (source.hasOwnProperty(nextKey)) {\n              output[nextKey] = source[nextKey];\n            }\n          }\n        }\n      }\n\n      return output;\n    };\n  } // returns whether an argument is a reference to an object,\n  // which is legal as a WeakMap key.\n\n\n  function isObject(arg) {\n    var type = typeof arg;\n    return type === 'object' && arg !== null || type === 'function';\n  }\n\n  ; // a wrapper for WeakMap.get which returns the undefined value\n  // for keys that are not objects (in which case the underlying\n  // WeakMap would have thrown a TypeError).\n\n  function safeWeakMapGet(map, key) {\n    return isObject(key) ? map.get(key) : undefined;\n  }\n\n  ; // returns a new function of zero arguments that recursively\n  // unwraps any proxies specified as the |this|-value.\n  // The primitive is assumed to be a zero-argument method\n  // that uses its |this|-binding.\n\n  function makeUnwrapping0ArgMethod(primitive) {\n    return function builtin() {\n      var vHandler = safeWeakMapGet(directProxies, this);\n\n      if (vHandler !== undefined) {\n        return builtin.call(vHandler.target);\n      } else {\n        return primitive.call(this);\n      }\n    };\n  }\n\n  ; // returns a new function of 1 arguments that recursively\n  // unwraps any proxies specified as the |this|-value.\n  // The primitive is assumed to be a 1-argument method\n  // that uses its |this|-binding.\n\n  function makeUnwrapping1ArgMethod(primitive) {\n    return function builtin(arg) {\n      var vHandler = safeWeakMapGet(directProxies, this);\n\n      if (vHandler !== undefined) {\n        return builtin.call(vHandler.target, arg);\n      } else {\n        return primitive.call(this, arg);\n      }\n    };\n  }\n\n  ;\n  Object.prototype.valueOf = makeUnwrapping0ArgMethod(Object.prototype.valueOf);\n  Object.prototype.toString = makeUnwrapping0ArgMethod(Object.prototype.toString);\n  Function.prototype.toString = makeUnwrapping0ArgMethod(Function.prototype.toString);\n  Date.prototype.toString = makeUnwrapping0ArgMethod(Date.prototype.toString);\n\n  Object.prototype.isPrototypeOf = function builtin(arg) {\n    // bugfix thanks to Bill Mark:\n    // built-in isPrototypeOf does not unwrap proxies used\n    // as arguments. So, we implement the builtin ourselves,\n    // based on the ECMAScript 6 spec. Our encoding will\n    // make sure that if a proxy is used as an argument,\n    // its getPrototypeOf trap will be called.\n    while (true) {\n      var vHandler2 = safeWeakMapGet(directProxies, arg);\n\n      if (vHandler2 !== undefined) {\n        arg = vHandler2.getPrototypeOf();\n\n        if (arg === null) {\n          return false;\n        } else if (sameValue(arg, this)) {\n          return true;\n        }\n      } else {\n        return prim_isPrototypeOf.call(this, arg);\n      }\n    }\n  };\n\n  Array.isArray = function (subject) {\n    var vHandler = safeWeakMapGet(directProxies, subject);\n\n    if (vHandler !== undefined) {\n      return Array.isArray(vHandler.target);\n    } else {\n      return prim_isArray(subject);\n    }\n  };\n\n  function isProxyArray(arg) {\n    var vHandler = safeWeakMapGet(directProxies, arg);\n\n    if (vHandler !== undefined) {\n      return Array.isArray(vHandler.target);\n    }\n\n    return false;\n  } // Array.prototype.concat internally tests whether one of its\n  // arguments is an Array, by checking whether [[Class]] == \"Array\"\n  // As such, it will fail to recognize proxies-for-arrays as arrays.\n  // We patch Array.prototype.concat so that it \"unwraps\" proxies-for-arrays\n  // by making a copy. This will trigger the exact same sequence of\n  // traps on the proxy-for-array as if we would not have unwrapped it.\n  // See <https://github.com/tvcutsem/harmony-reflect/issues/19> for more.\n\n\n  Array.prototype.concat = function\n    /*...args*/\n  () {\n    var length;\n\n    for (var i = 0; i < arguments.length; i++) {\n      if (isProxyArray(arguments[i])) {\n        length = arguments[i].length;\n        arguments[i] = Array.prototype.slice.call(arguments[i], 0, length);\n      }\n    }\n\n    return prim_concat.apply(this, arguments);\n  }; // setPrototypeOf support on platforms that support __proto__\n\n\n  var prim_setPrototypeOf = Object.setPrototypeOf; // patch and extract original __proto__ setter\n\n  var __proto__setter = function () {\n    var protoDesc = prim_getOwnPropertyDescriptor(Object.prototype, '__proto__');\n\n    if (protoDesc === undefined || typeof protoDesc.set !== \"function\") {\n      return function () {\n        throw new TypeError(\"setPrototypeOf not supported on this platform\");\n      };\n    } // see if we can actually mutate a prototype with the generic setter\n    // (e.g. Chrome v28 doesn't allow setting __proto__ via the generic setter)\n\n\n    try {\n      protoDesc.set.call({}, {});\n    } catch (e) {\n      return function () {\n        throw new TypeError(\"setPrototypeOf not supported on this platform\");\n      };\n    }\n\n    prim_defineProperty(Object.prototype, '__proto__', {\n      set: function set(newProto) {\n        return Object.setPrototypeOf(this, Object(newProto));\n      }\n    });\n    return protoDesc.set;\n  }();\n\n  Object.setPrototypeOf = function (target, newProto) {\n    var handler = directProxies.get(target);\n\n    if (handler !== undefined) {\n      if (handler.setPrototypeOf(newProto)) {\n        return target;\n      } else {\n        throw new TypeError(\"proxy rejected prototype mutation\");\n      }\n    } else {\n      if (!Object_isExtensible(target)) {\n        throw new TypeError(\"can't set prototype on non-extensible object: \" + target);\n      }\n\n      if (prim_setPrototypeOf) return prim_setPrototypeOf(target, newProto);\n\n      if (Object(newProto) !== newProto || newProto === null) {\n        throw new TypeError(\"Object prototype may only be an Object or null: \" + newProto); // throw new TypeError(\"prototype must be an object or null\")\n      }\n\n      __proto__setter.call(target, newProto);\n\n      return target;\n    }\n  };\n\n  Object.prototype.hasOwnProperty = function (name) {\n    var handler = safeWeakMapGet(directProxies, this);\n\n    if (handler !== undefined) {\n      var desc = handler.getOwnPropertyDescriptor(name);\n      return desc !== undefined;\n    } else {\n      return prim_hasOwnProperty.call(this, name);\n    }\n  }; // ============= Reflection module =============\n  // see http://wiki.ecmascript.org/doku.php?id=harmony:reflect_api\n\n\n  var Reflect = {\n    getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, name) {\n      return Object.getOwnPropertyDescriptor(target, name);\n    },\n    defineProperty: function defineProperty(target, name, desc) {\n      // if target is a proxy, invoke its \"defineProperty\" trap\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.defineProperty(target, name, desc);\n      } // Implementation transliterated from [[DefineOwnProperty]]\n      // see ES5.1 section 8.12.9\n      // this is the _exact same algorithm_ as the isCompatibleDescriptor\n      // algorithm defined above, except that at every place it\n      // returns true, this algorithm actually does define the property.\n\n\n      var current = Object.getOwnPropertyDescriptor(target, name);\n      var extensible = Object.isExtensible(target);\n\n      if (current === undefined && extensible === false) {\n        return false;\n      }\n\n      if (current === undefined && extensible === true) {\n        Object.defineProperty(target, name, desc); // should never fail\n\n        return true;\n      }\n\n      if (isEmptyDescriptor(desc)) {\n        return true;\n      }\n\n      if (isEquivalentDescriptor(current, desc)) {\n        return true;\n      }\n\n      if (current.configurable === false) {\n        if (desc.configurable === true) {\n          return false;\n        }\n\n        if ('enumerable' in desc && desc.enumerable !== current.enumerable) {\n          return false;\n        }\n      }\n\n      if (isGenericDescriptor(desc)) {// no further validation necessary\n      } else if (isDataDescriptor(current) !== isDataDescriptor(desc)) {\n        if (current.configurable === false) {\n          return false;\n        }\n      } else if (isDataDescriptor(current) && isDataDescriptor(desc)) {\n        if (current.configurable === false) {\n          if (current.writable === false && desc.writable === true) {\n            return false;\n          }\n\n          if (current.writable === false) {\n            if ('value' in desc && !sameValue(desc.value, current.value)) {\n              return false;\n            }\n          }\n        }\n      } else if (isAccessorDescriptor(current) && isAccessorDescriptor(desc)) {\n        if (current.configurable === false) {\n          if ('set' in desc && !sameValue(desc.set, current.set)) {\n            return false;\n          }\n\n          if ('get' in desc && !sameValue(desc.get, current.get)) {\n            return false;\n          }\n        }\n      }\n\n      Object.defineProperty(target, name, desc); // should never fail\n\n      return true;\n    },\n    deleteProperty: function deleteProperty(target, name) {\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.delete(name);\n      }\n\n      var desc = Object.getOwnPropertyDescriptor(target, name);\n\n      if (desc === undefined) {\n        return true;\n      }\n\n      if (desc.configurable === true) {\n        delete target[name];\n        return true;\n      }\n\n      return false;\n    },\n    getPrototypeOf: function getPrototypeOf(target) {\n      return Object.getPrototypeOf(target);\n    },\n    setPrototypeOf: function setPrototypeOf(target, newProto) {\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.setPrototypeOf(newProto);\n      }\n\n      if (Object(newProto) !== newProto || newProto === null) {\n        throw new TypeError(\"Object prototype may only be an Object or null: \" + newProto);\n      }\n\n      if (!Object_isExtensible(target)) {\n        return false;\n      }\n\n      var current = Object.getPrototypeOf(target);\n\n      if (sameValue(current, newProto)) {\n        return true;\n      }\n\n      if (prim_setPrototypeOf) {\n        try {\n          prim_setPrototypeOf(target, newProto);\n          return true;\n        } catch (e) {\n          return false;\n        }\n      }\n\n      __proto__setter.call(target, newProto);\n\n      return true;\n    },\n    preventExtensions: function preventExtensions(target) {\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.preventExtensions();\n      }\n\n      prim_preventExtensions(target);\n      return true;\n    },\n    isExtensible: function isExtensible(target) {\n      return Object.isExtensible(target);\n    },\n    has: function has(target, name) {\n      return name in target;\n    },\n    get: function get(target, name, receiver) {\n      receiver = receiver || target; // if target is a proxy, invoke its \"get\" trap\n\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.get(receiver, name);\n      }\n\n      var desc = Object.getOwnPropertyDescriptor(target, name);\n\n      if (desc === undefined) {\n        var proto = Object.getPrototypeOf(target);\n\n        if (proto === null) {\n          return undefined;\n        }\n\n        return Reflect.get(proto, name, receiver);\n      }\n\n      if (isDataDescriptor(desc)) {\n        return desc.value;\n      }\n\n      var getter = desc.get;\n\n      if (getter === undefined) {\n        return undefined;\n      }\n\n      return desc.get.call(receiver);\n    },\n    // Reflect.set implementation based on latest version of [[SetP]] at\n    // http://wiki.ecmascript.org/doku.php?id=harmony:proto_climbing_refactoring\n    set: function set(target, name, value, receiver) {\n      receiver = receiver || target; // if target is a proxy, invoke its \"set\" trap\n\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.set(receiver, name, value);\n      } // first, check whether target has a non-writable property\n      // shadowing name on receiver\n\n\n      var ownDesc = Object.getOwnPropertyDescriptor(target, name);\n\n      if (ownDesc === undefined) {\n        // name is not defined in target, search target's prototype\n        var proto = Object.getPrototypeOf(target);\n\n        if (proto !== null) {\n          // continue the search in target's prototype\n          return Reflect.set(proto, name, value, receiver);\n        } // Rev16 change. Cf. https://bugs.ecmascript.org/show_bug.cgi?id=1549\n        // target was the last prototype, now we know that 'name' is not shadowed\n        // by an existing (accessor or data) property, so we can add the property\n        // to the initial receiver object\n        // (this branch will intentionally fall through to the code below)\n\n\n        ownDesc = {\n          value: undefined,\n          writable: true,\n          enumerable: true,\n          configurable: true\n        };\n      } // we now know that ownDesc !== undefined\n\n\n      if (isAccessorDescriptor(ownDesc)) {\n        var setter = ownDesc.set;\n        if (setter === undefined) return false;\n        setter.call(receiver, value); // assumes Function.prototype.call\n\n        return true;\n      } // otherwise, isDataDescriptor(ownDesc) must be true\n\n\n      if (ownDesc.writable === false) return false; // we found an existing writable data property on the prototype chain.\n      // Now update or add the data property on the receiver, depending on\n      // whether the receiver already defines the property or not.\n\n      var existingDesc = Object.getOwnPropertyDescriptor(receiver, name);\n\n      if (existingDesc !== undefined) {\n        var updateDesc = {\n          value: value,\n          // FIXME: it should not be necessary to describe the following\n          // attributes. Added to circumvent a bug in tracemonkey:\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=601329\n          writable: existingDesc.writable,\n          enumerable: existingDesc.enumerable,\n          configurable: existingDesc.configurable\n        };\n        Object.defineProperty(receiver, name, updateDesc);\n        return true;\n      } else {\n        if (!Object.isExtensible(receiver)) return false;\n        var newDesc = {\n          value: value,\n          writable: true,\n          enumerable: true,\n          configurable: true\n        };\n        Object.defineProperty(receiver, name, newDesc);\n        return true;\n      }\n    },\n\n    /*invoke: function(target, name, args, receiver) {\n      receiver = receiver || target;\n       var handler = directProxies.get(target);\n      if (handler !== undefined) {\n        return handler.invoke(receiver, name, args);\n      }\n       var fun = Reflect.get(target, name, receiver);\n      return Function.prototype.apply.call(fun, receiver, args);\n    },*/\n    enumerate: function enumerate(target) {\n      var handler = directProxies.get(target);\n      var result;\n\n      if (handler !== undefined) {\n        // handler.enumerate should return an iterator directly, but the\n        // iterator gets converted to an array for backward-compat reasons,\n        // so we must re-iterate over the array\n        result = handler.enumerate(handler.target);\n      } else {\n        result = [];\n\n        for (var name in target) {\n          result.push(name);\n        }\n\n        ;\n      }\n\n      var l = +result.length;\n      var idx = 0;\n      return {\n        next: function next() {\n          if (idx === l) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: result[idx++]\n          };\n        }\n      };\n    },\n    // imperfect ownKeys implementation: in ES6, should also include\n    // symbol-keyed properties.\n    ownKeys: function ownKeys(target) {\n      return Object_getOwnPropertyNames(target);\n    },\n    apply: function apply(target, receiver, args) {\n      // target.apply(receiver, args)\n      return Function.prototype.apply.call(target, receiver, args);\n    },\n    construct: function construct(target, args, newTarget) {\n      // return new target(...args);\n      // if target is a proxy, invoke its \"construct\" trap\n      var handler = directProxies.get(target);\n\n      if (handler !== undefined) {\n        return handler.construct(handler.target, args, newTarget);\n      }\n\n      if (typeof target !== \"function\") {\n        throw new TypeError(\"target is not a function: \" + target);\n      }\n\n      if (newTarget === undefined || newTarget === target) {\n        // If newTarget is undefined, then newTarget is set to `target` and\n        // `Reflect.construct(target, ...args)` becomes equivalent to\n        // `new target(...args)`\n        // if `target` is an ES2015 Class constructor, it must be called using\n        // the `new` operator. Hence we use the new operator on a bound function\n        // to trigger the [[Construct]] internal method. This technique will work \n        // for both plain constructor functions and ES2015 classes\n        return new (Function.prototype.bind.apply(target, [null].concat(args)))();\n      } else {\n        if (typeof newTarget !== \"function\") {\n          throw new TypeError(\"newTarget is not a function: \" + target);\n        } // if newTarget is a *different* constructor function, we need to\n        // emulate [[Construct]] by falling back to [[Call]] with a hand-crafted\n        // new instance inheriting from newTarget.prototype\n        // Unfortunately this won't work if target is an ES2015 Constructor\n        // function, whose [[Call]] method throws an error (it must be invoked\n        // using the `new` operator)\n\n\n        var proto = newTarget.prototype;\n        var instance = Object(proto) === proto ? Object.create(proto) : {};\n        var result = Function.prototype.apply.call(target, instance, args);\n        return Object(result) === result ? result : instance;\n      }\n    }\n  }; // feature-test whether the Reflect global exists\n\n  if (global.Reflect !== undefined) {\n    // Reflect exists, add/override the shimmed methods\n    Object.getOwnPropertyNames(Reflect).forEach(function (key) {\n      global.Reflect[key] = Reflect[key];\n    });\n  } else {\n    // Reflect doesn't exist, define it as the shimmed Reflect object\n    global.Reflect = Reflect;\n  } // feature-test whether the Proxy global exists, with\n  // the harmony-era Proxy.create API\n\n\n  if (typeof Proxy !== \"undefined\" && typeof Proxy.create !== \"undefined\") {\n    var primCreate = Proxy.create,\n        primCreateFunction = Proxy.createFunction;\n    var revokedHandler = primCreate({\n      get: function get() {\n        throw new TypeError(\"proxy is revoked\");\n      }\n    });\n\n    global.Proxy = function (target, handler) {\n      // check that target is an Object\n      if (Object(target) !== target) {\n        throw new TypeError(\"Proxy target must be an Object, given \" + target);\n      } // check that handler is an Object\n\n\n      if (Object(handler) !== handler) {\n        throw new TypeError(\"Proxy handler must be an Object, given \" + handler);\n      }\n\n      var vHandler = new Validator(target, handler);\n      var proxy;\n\n      if (typeof target === \"function\") {\n        proxy = primCreateFunction(vHandler, // call trap\n        function () {\n          var args = Array.prototype.slice.call(arguments);\n          return vHandler.apply(target, this, args);\n        }, // construct trap\n        function () {\n          var args = Array.prototype.slice.call(arguments);\n          return vHandler.construct(target, args);\n        });\n      } else {\n        proxy = primCreate(vHandler, Object.getPrototypeOf(target));\n      }\n\n      directProxies.set(proxy, vHandler);\n      return proxy;\n    };\n\n    global.Proxy.revocable = function (target, handler) {\n      var proxy = new Proxy(target, handler);\n\n      var revoke = function revoke() {\n        var vHandler = directProxies.get(proxy);\n\n        if (vHandler !== null) {\n          vHandler.target = null;\n          vHandler.handler = revokedHandler;\n        }\n\n        return undefined;\n      };\n\n      return {\n        proxy: proxy,\n        revoke: revoke\n      };\n    }; // add the old Proxy.create and Proxy.createFunction methods\n    // so old code that still depends on the harmony-era Proxy object\n    // is not broken. Also ensures that multiple versions of this\n    // library should load fine\n\n\n    global.Proxy.create = primCreate;\n    global.Proxy.createFunction = primCreateFunction;\n  } else {\n    // Proxy global not defined, or old API not available\n    if (typeof Proxy === \"undefined\") {\n      // Proxy global not defined, add a Proxy function stub\n      global.Proxy = function (_target, _handler) {\n        throw new Error(\"proxies not supported on this platform. On v8/node/iojs, make sure to pass the --harmony_proxies flag\");\n      };\n    } // Proxy global defined but old API not available\n    // presumably Proxy global already supports new API, leave untouched\n\n  } // for node.js modules, export every property in the Reflect object\n  // as part of the module interface\n\n\n  if (typeof exports !== 'undefined') {\n    Object.keys(Reflect).forEach(function (key) {\n      exports[key] = Reflect[key];\n    });\n  } // function-as-module pattern\n\n})(typeof exports !== 'undefined' ? global : this);","map":null,"metadata":{},"sourceType":"script"}